[「LibreOJ β Round #2」贪心只能过样例](https://loj.ac/p/515)
### 题目描述

一共有$n$个数，第$i$个数$x_i$可以取$[a_i,b_i]$区间中任意值。
设$S=\sum{x_i^2}$，求$S$种类数。


#### 样例

##### 输入

```
2
1 2
2 3
```

##### 输出

```
4
```

##### 输入

```
5
1 2
2 3
3 4
4 5
5 6
```

##### 输出

```
26
```

#### 样例1解释

$1^2+2^2=5$
$1^2+3^2=10$
$2^2+2^2=8$
$2^2+3^2=13$
有四种可能所以结果为4

#### 数据范围

$1\le n,a_i,b_i\le 100$

不会dp。暴搜的话$2^100$复杂度过高，用`std::bitset`的1表示结果中的状态，我自己想的话可能会用map存，但是太浪费空间了。

### bitset在例题中的原理介绍

可以用bitset中的1表示一种可能的结果，用1前面的比特数表示结果的大小，比如$1^2+2^2=5$用`std::bitset`可表示为

```c++
std::bitset<N> a;
a[0] = 1; // 将bitset的第一位设为1，这样可以进行移位操作。
              //因为1<<n=2^n，而0<<n=0不起作用
a <<= (1 * 1);
a <<= (2 * 2);
```

输出a的前5位为000001。

可以看到1前面有5个0，即1右移5位来的。

加法可以看成右移，比如2+3=5
$001(2)<<3=000001(5)$

### 复杂度分析

例子中最大数为$100^2\times 100$，所以bitset可以开到$101^3$。

拿**样例1**做解释，我们可以得到的bitset应该是00000100101001000000
我们可以拿n作为n轮循环将区间内的数字添加到bitset中，
- 第一轮将$1^2$添加到b中，开始时移位的基底为1，右移一位可得01，再将$2^2$添加到b中，基底右移4位可得00001然后将它加到01中这里采用`|`或运算得到01001
- 第二轮将上一轮得到的01001作为移位的基底，右移四位($2\times 2$)可得000001001，基底右移九位($3\times 3$)可得00000000001001，加在一起得00000100101001
总共有4个1，结果分别为5，8，10，13

每一轮循环的基底为上一次的bit集，所以开一个长度为n的bitset数组。

外层循环复杂度为n，每一轮循环最大复杂度为最大区间长度为100，所以复杂度为$100^2$

### 代码编写

> 一定不要忽略代码的编写和原理的分析

```c++
int a[N], b[N];
std::bitset<101 * 101 * 101> c[N];
// 输入a和b
c[0][0] = 1; // 第一轮使用的基底为c[0]，将c[0]变为1只需要将c[0]的第一位变为1
for (int i = 1; i < n; i++) {
    for (int j = a[i]; j <= b[i]; j++) {
        c[i] |= c[i - 1] << j * j;
    }
}
std::cout << b[n].count(); // bitset的count方法表示bitset中一的个数
```

### bitset的优点

当我们得到一个状态加入是0101001，如果不用bitset就是有三个数字1，3，6，如果我们将其加上[4, 6]区间的每一个数字求可能的结果方案数，我们需要对1，3，6分别加上4，5，6，相当于求9次，如果用bitset可以用0101001分别加上4，5，6，然后取并集。

不用bitset只打暴力就是区间长度的n次方，而用bitset就是n的区间长度之和。
