## 题目描述

给你一个长度为n的排列a，**排列**定义为由1到n组成的任意顺序的数组。

你有s的能量操作排列$a$ $n$次。

第i次移动规则
- 选择两个整数x和y，x和y满足$i\le x\le y\le min(i+s,n)$，交换x和y在排列a中的位置

你能够在n次操作后将a变为另一个排列b。但是b中的一些元素被-1取代。

计算出使用s能量操作a变成将b中的-1替换成1到n中的数使得b变为排列的可能的情况数。

取模

## 输入(只考虑一次)

- 第一行输入长度n和能量s，
- 第二行输入排列a的n个元素，$a_1,a_2,...,a_n(1\le a_i\le n)$
- 第三行输入排列b的n个元素，$b_1,b_2,...,b_n(1\le b_i\le b 或者 b=-1)$

## 输出

输出使用能量s将a转化为排列b的方案数。

## 题目可证明的结论

$max(a_i-b_i)\le s(如果a_i>b_i)$

正面证很难，我们就假设$a_i-b_i>s$

假设需要交换的数字为x和z，中间跳板为y

- 假设a中的跳板y本身对应b中的y

![](https://github.com/swapfloor/blog/blob/main/images/swap1.png)

需要交换三次(x,y);(y,z);(x,y);

$t1\le x\le y\le t1+s$

$t2\le y\le z\le t2+s$

$t3\le x\le y\le t3+s$
$t1<t2<t3$

$z-x>s$所以t2>t1,t2>t3,与已经条件矛盾。

加入有一个i满足$a_i-b_i>s$，所以如果调整$a_i$时间经过了$b_i$，那么$b_i$应该已经被调好了，要不然没有机会去调。从反面印证了$a_i-b_i<=s$

将-1替代的数字存入容器中，用取得ai-s在容器中的位置为j，对于容器即b来说可以大一点，所以种类方案为最后位置-j，大的先进行挑选。

`if(b[i] != -1) vis[b[i]] = true; if(vis[i] == false) missing.push(a[i]);`

`j = lower_bound(missing.begin(), missing.end(), a[i] - s); cnt.push(missing.end() - j);`

`sort(cnt.begin(), cnt.end());`

$ans=\prod_{i = 0}^{cnt.size() - 1}(cnt[i] - i)$
