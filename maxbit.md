# 一道魔数相关例题（来自cs:app）

## 题目描述

给出一个数x，求出x的二进制最高位是第几位[1, 31]？

## 例

```
input:0x80000000
output:32

input:298
output:9
```

朴素：
- 不断右移的最后一个1的位置即为二进制最高位，这是需要时间为len(bin(x))

奇思：
- 有一种做法常数解决，对于一个32位的数字，我们总可以不断的询问其特定区间是否有1这个数字。

需要用到”[与运算](https://baike.baidu.com/item/%E4%B8%8E/13025631?fromtitle=%E4%B8%8E%E8%BF%90%E7%AE%97)“&。

对于一个数字我们可以将他切成两半，一半根0xffff0000有交集，一半根0x0000ffff有交集，

如果根0xffff0000有交集，询问其与0xff000000的交集存在与否。

二分子集缩小0xffff -> 0xff -> 0xf -> 0x11 -> 0x1

```c
int sol(int x) {
    int n = 0;
	if (!x) return 0;
  /*
    n表示上一次匹配与否，
    写一个小模拟，n开始为0，所以第一行(~0 << n + 16)表示t0 = 0xffff0000，如果x & t0 != 0，则需要抬升16位，
    这样我们下一次要与0xff000000这是24位，本身第二次二分是32/2/2=8位，还有16位应该是第一次抬升，所以要加在n上。
  */
	n += (!!(x & (~0 << n + 16))) << 4;
	n += (!!(x & (~0 << n +  8))) << 3;
	n += (!!(x & (~0 << n +  4))) << 2;
	n += (!!(x & (~0 << n +  2))) << 1;
	n += (!!(x & (~0 << n +  1))) << 0;
	return n + 1;
}
```
